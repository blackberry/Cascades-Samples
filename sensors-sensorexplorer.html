<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- sensorexplorer.qdoc -->
  <title>Cascades : Sensor Explorer Example</title>
  <link rel="stylesheet" type="text/css" href="style/offline.css" />
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="content"> 
    <a href="index.html" class="qtref"><span>Qt-based BB10 API Examples Documentation</span></a>
  </div>
  <div class="breadcrumb toolblock">
    <ul>
      <li class="first"><a href="index.html">Home</a></li>
      <!--  Breadcrumbs go here -->
    </ul>
  </div>
</div>
<div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#description">Description</a></li>
<li class="level1"><a href="#overview">Overview</a></li>
<li class="level1"><a href="#the-ui">The UI</a></li>
<li class="level1"><a href="#sensorexplorer">SensorExplorer</a></li>
</ul>
</div>
<h1 class="title">Sensor Explorer Example</h1>
<span class="subtitle"></span>
<!-- $$$sensors/sensorexplorer-description -->
<div class="descr"> <a name="details"></a>
<p>Files:</p>
<ul>
<li><a href="sensors-sensorexplorer-assets-readingpage-qml.html">sensors/sensorexplorer/assets/ReadingPage.qml</a></li>
<li><a href="sensors-sensorexplorer-assets-sensorpage-qml.html">sensors/sensorexplorer/assets/SensorPage.qml</a></li>
<li><a href="sensors-sensorexplorer-assets-main-qml.html">sensors/sensorexplorer/assets/main.qml</a></li>
<li><a href="sensors-sensorexplorer-src-sensorexplorer-cpp.html">sensors/sensorexplorer/src/SensorExplorer.cpp</a></li>
<li><a href="sensors-sensorexplorer-src-sensorexplorer-hpp.html">sensors/sensorexplorer/src/SensorExplorer.hpp</a></li>
<li><a href="sensors-sensorexplorer-src-main-cpp.html">sensors/sensorexplorer/src/main.cpp</a></li>
<li><a href="sensors-sensorexplorer-sensorexplorer-pro.html">sensors/sensorexplorer/sensorexplorer.pro</a></li>
<li><a href="sensors-sensorexplorer-translations-sensorexplorer-pro.html">sensors/sensorexplorer/translations/sensorexplorer.pro</a></li>
</ul>
<a name="description"></a>
<h2>Description</h2>
<p>The Sensor Explorer example demonstrates how to introspect all available sensors of a device.</p>
<div class="centerAlign"><p><img src="images/sensorexplorer-example.png" alt="" /> <img src="images/sensorexplorer-example1.png" alt="" /> <img src="images/sensorexplorer-example2.png" alt="" /></p>
</div><a name="overview"></a>
<h2>Overview</h2>
<p>In this example we'll learn how to use the QSensor and QSensorReading classes together with the meta-object system of Qt to introspect all available sensors of the device and show their current sensor data.</p>
<a name="the-ui"></a>
<h2>The UI</h2>
<p>The UI of this sample application consists of three screens. The first screen shows the list of all available sensors of the device. When the user selects on of the sensors the second screen is presented, which shows all properties of the sensor with name, type and current value. The user can start the sensor in this screen and use the 'Values' button to show up the third screen. The third screen shows now all the values that are read from the sensor and they are updated whenever the hardware sensor updates its data.</p>
<p>The business logic of the application is encapsulated in the <tt>SensorExplorer</tt> class which is made available to the UI under the name '<a href="#sensorexplorer">_sensorExplorer</a>'.</p>
<pre class="qml">                <span class="type">ListView</span> {
                    <span class="name">horizontalAlignment</span>: <span class="name">HorizontalAlignment</span>.<span class="name">Fill</span>
                    <span class="name">layoutProperties</span>: <span class="name">StackLayoutProperties</span> {
                        <span class="name">spaceQuota</span>: <span class="number">1</span>
                    }

                    <span class="name">dataModel</span>: <span class="name">_sensorExplorer</span>.<span class="name">sensorsModel</span>

                    <span class="name">onTriggered</span>: {
                        <span class="name">clearSelection</span>();
                        <span class="name">select</span>(<span class="name">indexPath</span>);
                    }

                    <span class="name">onSelectionChanged</span>: {
                        <span class="keyword">if</span> (<span class="name">selected</span>) {
                            <span class="name">_sensorExplorer</span>.<span class="name">setCurrentSensor</span>(<span class="name">indexPath</span>)
                            <span class="name">navigationPane</span>.<span class="name">push</span>(<span class="name">sensorPage</span>.<span class="name">createObject</span>());
                        }
                    }

                    <span class="name">attachedObjects</span>: [
                        <span class="type">ComponentDefinition</span> {
                            <span class="name">id</span>: <span class="name">sensorPage</span>
                            <span class="name">source</span>: <span class="string">&quot;SensorPage.qml&quot;</span>
                        }
                    ]
                }</pre>
<p>Beside a title label, the first page contains a <tt>ListView</tt> that shows all the available sensors. The list of sensors is provided by a <tt>DataModel</tt> that is made available by the <tt>SensorExplorer</tt>'s 'sensorModel' property. When the user selects a sensor, we invoke the <tt>setCurrentSensor</tt> method of the <tt>SensorExplorer</tt> object. That will trigger the <tt>SensorExplorer</tt> to update all meta-data and values for this sensor. Additionally we push the sensor page (2nd screen) on the navigation pane.</p>
<pre class="qml">            <span class="type">ListView</span> {
                <span class="name">horizontalAlignment</span>: <span class="name">HorizontalAlignment</span>.<span class="name">Fill</span>
                <span class="name">layoutProperties</span>: <span class="name">StackLayoutProperties</span> {
                    <span class="name">spaceQuota</span>: <span class="number">1</span>
                }

                <span class="name">dataModel</span>: <span class="name">_sensorExplorer</span>.<span class="name">sensorPropertiesModel</span>

                <span class="name">listItemComponents</span>: [
                    <span class="type">ListItemComponent</span> {
                        <span class="name">type</span>: <span class="string">&quot;item&quot;</span>
                        <span class="type">StandardListItem</span> {
                            <span class="name">title</span>: <span class="name">ListItemData</span>.<span class="name">name</span>
                            <span class="name">status</span>: <span class="name">ListItemData</span>.<span class="name">type</span>
                            <span class="name">description</span>: <span class="name">ListItemData</span>.<span class="name">value</span>
                        }
                    }
                ]
            }</pre>
<p>The sensor page contains a <tt>ListView</tt> as well, which shows all properties of the selected sensor. The list of properties is provided by a <tt>DataModel</tt> that is made available by the <a href="#sensorexplorer">SensorExplorer</a>'s 'sensorPropertiesModel' property. This time we use a <tt>StandardListItem</tt> control for the list view entries and assign the name, type and value of the property to its labels.</p>
<pre class="qml">                <span class="type">Button</span> {
                    <span class="name">text</span>: <span class="name">_sensorExplorer</span>.<span class="name">sensorActive</span> ? <span class="name">qsTr</span> (<span class="string">&quot;Stop&quot;</span>) : <span class="name">qsTr</span> (<span class="string">&quot;Start&quot;</span>)
                    <span class="name">onClicked</span>: <span class="name">_sensorExplorer</span>.<span class="name">sensorActive</span> <span class="operator">=</span> !<span class="name">_sensorExplorer</span>.<span class="name">sensorActive</span>
                }

                <span class="type">Button</span> {
                    <span class="name">text</span>: <span class="name">qsTr</span> (<span class="string">&quot;Values&quot;</span>)

                    <span class="name">onClicked</span>: {
                        <span class="name">navigationPane</span>.<span class="name">push</span>(<span class="name">readingPage</span>.<span class="name">createObject</span>());
                    }
                    <span class="name">attachedObjects</span>: [
                        <span class="type">ComponentDefinition</span> {
                            <span class="name">id</span>: <span class="name">readingPage</span>
                            <span class="name">source</span>: <span class="string">&quot;ReadingPage.qml&quot;</span>
                        }
                    ]
                }</pre>
<p>The first button in the sensor page allows the user to start or stop the sensor. The text of this button depends on the 'sensorActivity' property of the <tt>SensorExplorer</tt> and clicking the button will toggle this property.</p>
<p>If the user presses the 'Values' button, we push the reading page (3rd screen) on the navigation pane.</p>
<pre class="qml">            <span class="type">ListView</span> {
                <span class="name">horizontalAlignment</span>: <span class="name">HorizontalAlignment</span>.<span class="name">Fill</span>
                <span class="name">layoutProperties</span>: <span class="name">StackLayoutProperties</span> {
                    <span class="name">spaceQuota</span>: <span class="number">1</span>
                }

                <span class="name">dataModel</span>: <span class="name">_sensorExplorer</span>.<span class="name">readingPropertiesModel</span>

                <span class="name">listItemComponents</span>: [
                    <span class="type">ListItemComponent</span> {
                        <span class="name">type</span>: <span class="string">&quot;item&quot;</span>
                        <span class="type">StandardListItem</span> {
                            <span class="name">title</span>: <span class="name">ListItemData</span>.<span class="name">name</span>
                            <span class="name">status</span>: <span class="name">ListItemData</span>.<span class="name">type</span>
                            <span class="name">description</span>: <span class="name">ListItemData</span>.<span class="name">value</span>
                        }
                     }
                 ]
            }</pre>
<p>The reading page contains a similar list view like the sensor page, just that it uses the <tt>SensorExplorer</tt>'s 'readingPropertiesModel' as data model.</p>
<a name="sensorexplorer"></a>
<h2>SensorExplorer</h2>
<p>The <tt>SensorExplorer</tt> class encapsulates the business logic of the application. It uses the QSensor and QSensorReading classes internally to retrieve the available sensors and their properties. The data are provided to the UI through properties of type <tt>DataModel</tt>. An additional property 'sensorActive' defines whether the selected sensor is active or not.</p>
<pre class="cpp">    <span class="keyword">class</span> SensorExplorer : <span class="keyword">public</span> <span class="type">QObject</span><span class="operator">,</span> <span class="keyword">public</span> <span class="type">QSensorFilter</span>
    {
        Q_OBJECT

        Q_PROPERTY(bb<span class="operator">::</span>cascades<span class="operator">::</span>DataModel<span class="operator">*</span> sensorsModel READ sensorsModel CONSTANT)
        Q_PROPERTY(bb<span class="operator">::</span>cascades<span class="operator">::</span>DataModel<span class="operator">*</span> sensorPropertiesModel READ sensorPropertiesModel CONSTANT)
        Q_PROPERTY(bb<span class="operator">::</span>cascades<span class="operator">::</span>DataModel<span class="operator">*</span> readingPropertiesModel READ readingPropertiesModel CONSTANT)
        Q_PROPERTY(<span class="type">bool</span> sensorActive READ sensorActive WRITE setSensorActive NOTIFY sensorActiveChanged)

    <span class="keyword">public</span>:
        SensorExplorer(<span class="type">QObject</span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>);

        <span class="type">bool</span> filter(<span class="type">QSensorReading</span> <span class="operator">*</span>reading);

        bb<span class="operator">::</span>cascades<span class="operator">::</span>DataModel<span class="operator">*</span> sensorsModel() <span class="keyword">const</span>;
        bb<span class="operator">::</span>cascades<span class="operator">::</span>DataModel<span class="operator">*</span> sensorPropertiesModel() <span class="keyword">const</span>;
        bb<span class="operator">::</span>cascades<span class="operator">::</span>DataModel<span class="operator">*</span> readingPropertiesModel() <span class="keyword">const</span>;

        <span class="type">bool</span> sensorActive() <span class="keyword">const</span>;
        <span class="type">void</span> setSensorActive(<span class="type">bool</span> active);

    <span class="keyword">public</span> Q_SLOTS:
        <span class="type">void</span> setCurrentSensor(<span class="keyword">const</span> <span class="type">QVariantList</span> <span class="operator">&amp;</span>indexPath);

    Q_SIGNALS:
        <span class="type">void</span> sensorActiveChanged();

    <span class="keyword">private</span> Q_SLOTS:
        <span class="type">void</span> loadSensors();
        <span class="type">void</span> sensorChanged();

    <span class="keyword">private</span>:
        <span class="type">void</span> loadSensorProperties();
        <span class="type">void</span> loadReadingProperties();

        bb<span class="operator">::</span>cascades<span class="operator">::</span>GroupDataModel <span class="operator">*</span>m_sensorsModel;
        bb<span class="operator">::</span>cascades<span class="operator">::</span>GroupDataModel <span class="operator">*</span>m_sensorPropertiesModel;
        bb<span class="operator">::</span>cascades<span class="operator">::</span>GroupDataModel <span class="operator">*</span>m_readingPropertiesModel;

        <span class="type">QSensor</span> <span class="operator">*</span>m_sensor;
        qtimestamp m_lastReading;
    };</pre>
<p>Inside the constructor of <a href="#sensorexplorer">SensorExplorer</a> we initialize the data models with <tt>GroupDataModels</tt>, so that we can store the sensor and reading data inside them. We also switch of their grouping feature, since we don't want to show headers in the <tt>ListView</tt>. For the 'readingPropertiesModel' we specify a sort key, since we want to look up data in this model later on for on-the-fly updates of the values. At the end we trigger the initial load of the available sensors.</p>
<pre class="cpp">    SensorExplorer<span class="operator">::</span>SensorExplorer(<span class="type">QObject</span> <span class="operator">*</span>parent)
        : <span class="type">QObject</span>(parent)
        <span class="operator">,</span> m_sensorsModel(<span class="keyword">new</span> GroupDataModel(<span class="keyword">this</span>))
        <span class="operator">,</span> m_sensorPropertiesModel(<span class="keyword">new</span> GroupDataModel(<span class="keyword">this</span>))
        <span class="operator">,</span> m_readingPropertiesModel(<span class="keyword">new</span> GroupDataModel(<span class="type">QStringList</span>() <span class="operator">&lt;</span><span class="operator">&lt;</span> QLatin1String(<span class="string">&quot;position&quot;</span>)<span class="operator">,</span> <span class="keyword">this</span>))
        <span class="operator">,</span> m_sensor(<span class="number">0</span>)
        <span class="operator">,</span> m_lastReading(<span class="number">0</span>)
    {
        <span class="comment">// Don't use grouping in the models</span>
        m_sensorsModel<span class="operator">-</span><span class="operator">&gt;</span>setGrouping(ItemGrouping<span class="operator">::</span>None);
        m_sensorPropertiesModel<span class="operator">-</span><span class="operator">&gt;</span>setGrouping(ItemGrouping<span class="operator">::</span>None);
        m_readingPropertiesModel<span class="operator">-</span><span class="operator">&gt;</span>setGrouping(ItemGrouping<span class="operator">::</span>None);

        <span class="comment">// Trigger the initial load of the available sensors</span>
        loadSensors();
    }</pre>
<p>Inside <tt>loadSensors()</tt> we clear the content of the sensor model before we fill the model with new sensor data. For that we retrieve the information about all available sensor types (on each device their might be a different subset of supported sensors) and about all instances for these types (there might be multiple temperature sensors for example). After we checked that the sensor is functional, we add a new entry to the sensor model with the identifier and type of the sensor.</p>
<pre class="cpp">    <span class="type">void</span> SensorExplorer<span class="operator">::</span>loadSensors()
    {
        <span class="comment">// Clear out anything that's in there now</span>
        m_sensorsModel<span class="operator">-</span><span class="operator">&gt;</span>clear();

        <span class="comment">// Iterate over all available sensor types</span>
        foreach (<span class="keyword">const</span> <span class="type">QByteArray</span> <span class="operator">&amp;</span>type<span class="operator">,</span> <span class="type">QSensor</span><span class="operator">::</span>sensorTypes()) {

            <span class="comment">// Retrieve all identifiers for the current sensor type</span>
            foreach (<span class="keyword">const</span> <span class="type">QByteArray</span> <span class="operator">&amp;</span>identifier<span class="operator">,</span> <span class="type">QSensor</span><span class="operator">::</span>sensorsForType(type)) {

                <span class="keyword">if</span> (type <span class="operator">=</span><span class="operator">=</span> <span class="string">&quot;QHolsterSensor&quot;</span>)
                    <span class="keyword">continue</span>; <span class="comment">// prevent crash</span>

                <span class="comment">// Don't put in sensors we can't connect to</span>
                <span class="type">QSensor</span> sensor(type);
                sensor<span class="operator">.</span>setIdentifier(identifier);
                <span class="keyword">if</span> (<span class="operator">!</span>sensor<span class="operator">.</span>connectToBackend()) {
                    qDebug() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Couldn't connect to&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> identifier;
                    <span class="keyword">continue</span>;
                }

                <span class="comment">// Create a new model entry for the current sensor instance ...</span>
                <span class="type">QVariantMap</span> sensorEntry;
                sensorEntry<span class="operator">[</span><span class="string">&quot;identifier&quot;</span><span class="operator">]</span> <span class="operator">=</span> identifier;
                sensorEntry<span class="operator">[</span><span class="string">&quot;type&quot;</span><span class="operator">]</span> <span class="operator">=</span> <span class="type">QString</span><span class="operator">::</span>fromLatin1(type);

                <span class="comment">// ... and add it to the model</span>
                m_sensorsModel<span class="operator">-</span><span class="operator">&gt;</span>insert(sensorEntry);
            }
        }
    }</pre>
<p>If the user selects now one entry of that sensor model in the UI, the <tt>setCurrentSensor()</tt> method is invoked.</p>
<p>Inside this method we retrieve the identifier and type of the selected sensor and create a new QSensor instance from these data. Afterwards we trigger the propagation of the sensor properties and reading properties to the models.</p>
<pre class="cpp">    <span class="type">void</span> SensorExplorer<span class="operator">::</span>setCurrentSensor(<span class="keyword">const</span> <span class="type">QVariantList</span> <span class="operator">&amp;</span>indexPath)
    {
        <span class="comment">// Sanity check</span>
        <span class="keyword">if</span> (indexPath<span class="operator">.</span>isEmpty())
            <span class="keyword">return</span>;

        <span class="comment">// Clear out anything that's in there now</span>
        <span class="keyword">if</span> (m_sensor) {
            <span class="keyword">delete</span> m_sensor;
            m_sensor <span class="operator">=</span> <span class="number">0</span>;
        }

        m_sensorPropertiesModel<span class="operator">-</span><span class="operator">&gt;</span>clear();
        m_readingPropertiesModel<span class="operator">-</span><span class="operator">&gt;</span>clear();

        <span class="comment">// Retrieve the selected sensor description from the model</span>
        <span class="keyword">const</span> <span class="type">QVariantMap</span> sensorEntry <span class="operator">=</span> m_sensorsModel<span class="operator">-</span><span class="operator">&gt;</span>data(indexPath)<span class="operator">.</span>toMap();

        <span class="keyword">const</span> <span class="type">QByteArray</span> type <span class="operator">=</span> sensorEntry<span class="operator">[</span><span class="string">&quot;type&quot;</span><span class="operator">]</span><span class="operator">.</span>toString()<span class="operator">.</span>toLatin1();
        <span class="keyword">const</span> <span class="type">QByteArray</span> identifier <span class="operator">=</span> sensorEntry<span class="operator">[</span><span class="string">&quot;identifier&quot;</span><span class="operator">]</span><span class="operator">.</span>toString()<span class="operator">.</span>toLatin1();

        <span class="comment">// Connect to the sensor so we can probe it</span>
        m_sensor <span class="operator">=</span> <span class="keyword">new</span> <span class="type">QSensor</span>(type<span class="operator">,</span> <span class="keyword">this</span>);
        connect(m_sensor<span class="operator">,</span> SIGNAL(readingChanged())<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SLOT(sensorChanged()));
        connect(m_sensor<span class="operator">,</span> SIGNAL(activeChanged())<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SIGNAL(sensorActiveChanged()));
        m_sensor<span class="operator">-</span><span class="operator">&gt;</span>setIdentifier(identifier);
        <span class="keyword">if</span> (<span class="operator">!</span>m_sensor<span class="operator">-</span><span class="operator">&gt;</span>connectToBackend()) {
            <span class="keyword">delete</span> m_sensor;
            m_sensor <span class="operator">=</span> <span class="number">0</span>;
            qWarning() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Can't connect to the sensor!&quot;</span>;
            <span class="keyword">return</span>;
        }

        <span class="comment">// Trigger the load of the sensor and reading properties</span>
        loadSensorProperties();
        loadReadingProperties();
    }</pre>
<p>To fill the sensor properties model, we use the Qt's meta-object system for introspection. The QMetaObject of the QSensor instance allows us to iterate over all the properties that are provided by the sensor and retrieve their names, types and current values. For each property we create a new entry in the 'sensorPropertiesModel'.</p>
<pre class="cpp">    <span class="type">void</span> SensorExplorer<span class="operator">::</span>loadSensorProperties()
    {
        <span class="comment">// Sanity check</span>
        <span class="keyword">if</span> (<span class="operator">!</span>m_sensor)
            <span class="keyword">return</span>;

        <span class="comment">// Retrieve the meta data for the QSensor object ...</span>
        <span class="keyword">const</span> <span class="type">QMetaObject</span> <span class="operator">*</span>metaObject <span class="operator">=</span> m_sensor<span class="operator">-</span><span class="operator">&gt;</span>metaObject();
        <span class="keyword">const</span> <span class="type">int</span> firstProperty <span class="operator">=</span> <span class="type">QSensor</span><span class="operator">::</span>staticMetaObject<span class="operator">.</span>propertyOffset();

        <span class="comment">// ... and iterate over all its properties</span>
        <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> firstProperty; i <span class="operator">&lt;</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>propertyCount(); <span class="operator">+</span><span class="operator">+</span>i) {
            <span class="keyword">const</span> <span class="type">QString</span> name <span class="operator">=</span> <span class="type">QString</span><span class="operator">::</span>fromLatin1(metaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i)<span class="operator">.</span>name());

            <span class="keyword">if</span> (ignoreProperty(name)) <span class="comment">// hide certain properties</span>
                <span class="keyword">continue</span>;

            <span class="keyword">const</span> <span class="type">QString</span> type <span class="operator">=</span> typeName(metaObject<span class="operator">,</span> i);
            <span class="keyword">const</span> <span class="type">QVariant</span> value <span class="operator">=</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i)<span class="operator">.</span>read(m_sensor);

            <span class="comment">// Create a new model entry for the current property ...</span>
            <span class="type">QVariantMap</span> sensorPropertiesEntry;
            sensorPropertiesEntry<span class="operator">[</span><span class="string">&quot;type&quot;</span><span class="operator">]</span> <span class="operator">=</span> type;
            sensorPropertiesEntry<span class="operator">[</span><span class="string">&quot;name&quot;</span><span class="operator">]</span> <span class="operator">=</span> name;
            sensorPropertiesEntry<span class="operator">[</span><span class="string">&quot;value&quot;</span><span class="operator">]</span> <span class="operator">=</span> convertValue(type<span class="operator">,</span> value);

            <span class="comment">// ... and add it to the model</span>
            m_sensorPropertiesModel<span class="operator">-</span><span class="operator">&gt;</span>insert(sensorPropertiesEntry);
        }
    }</pre>
<p>Filling the reading properties model is similar to the previous method, just that we use the QMetaObject of the sensor's QSensorReading object.</p>
<pre class="cpp">    <span class="type">void</span> SensorExplorer<span class="operator">::</span>loadReadingProperties()
    {
        <span class="keyword">const</span> <span class="type">QSensorReading</span> <span class="operator">*</span>reading <span class="operator">=</span> m_sensor<span class="operator">-</span><span class="operator">&gt;</span>reading();

        <span class="comment">// Retrieve the meta data for the QSensorReading object ...</span>
        <span class="keyword">const</span> <span class="type">QMetaObject</span> <span class="operator">*</span>metaObject <span class="operator">=</span> reading<span class="operator">-</span><span class="operator">&gt;</span>metaObject();
        <span class="keyword">const</span> <span class="type">int</span> firstProperty <span class="operator">=</span> <span class="type">QSensorReading</span><span class="operator">::</span>staticMetaObject<span class="operator">.</span>propertyOffset();

        <span class="comment">// ... and iterate over all its properties</span>
        <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> firstProperty; i <span class="operator">&lt;</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>propertyCount(); <span class="operator">+</span><span class="operator">+</span>i) {
            <span class="keyword">const</span> <span class="type">int</span> position <span class="operator">=</span> i <span class="operator">-</span> firstProperty;

            <span class="keyword">const</span> <span class="type">QString</span> type <span class="operator">=</span> typeName(metaObject<span class="operator">,</span> i);
            <span class="keyword">const</span> <span class="type">QString</span> name <span class="operator">=</span> <span class="type">QString</span><span class="operator">::</span>fromLatin1(metaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i)<span class="operator">.</span>name());
            <span class="keyword">const</span> <span class="type">QVariant</span> value <span class="operator">=</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i)<span class="operator">.</span>read(reading);

            <span class="comment">// Create a new model entry for the current property ...</span>
            <span class="type">QVariantMap</span> readingEntry;
            readingEntry<span class="operator">[</span><span class="string">&quot;position&quot;</span><span class="operator">]</span> <span class="operator">=</span> position;
            readingEntry<span class="operator">[</span><span class="string">&quot;type&quot;</span><span class="operator">]</span> <span class="operator">=</span> type;
            readingEntry<span class="operator">[</span><span class="string">&quot;name&quot;</span><span class="operator">]</span> <span class="operator">=</span> name;
            readingEntry<span class="operator">[</span><span class="string">&quot;value&quot;</span><span class="operator">]</span> <span class="operator">=</span> convertValue(type<span class="operator">,</span> value);

            <span class="comment">// ... and add it to the model</span>
            m_readingPropertiesModel<span class="operator">-</span><span class="operator">&gt;</span>insert(readingEntry);
        }
    }</pre>
<p>Whenever the selected sensor reports new data, the filter method is invoked. To limit the number of updates in the UI, we check for the time that has passed since the last invocation. The rest of the method is similar to <tt>loadReadingProperties()</tt> with the difference that we do not insert a new entry in the model but update an existing one.</p>
<pre class="cpp">    <span class="type">bool</span> SensorExplorer<span class="operator">::</span>filter(<span class="type">QSensorReading</span> <span class="operator">*</span>reading)
    {
        <span class="comment">// Limit update interval to 1 second</span>
        <span class="keyword">if</span> ((reading<span class="operator">-</span><span class="operator">&gt;</span>timestamp() <span class="operator">-</span> m_lastReading) <span class="operator">&lt;</span> <span class="number">1000000</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;

        m_lastReading <span class="operator">=</span> reading<span class="operator">-</span><span class="operator">&gt;</span>timestamp();

        <span class="comment">// Retrieve the meta data for the QSensorReading object ...</span>
        <span class="keyword">const</span> <span class="type">QMetaObject</span> <span class="operator">*</span>metaObject <span class="operator">=</span> reading<span class="operator">-</span><span class="operator">&gt;</span>metaObject();
        <span class="keyword">const</span> <span class="type">int</span> firstProperty <span class="operator">=</span> <span class="type">QSensorReading</span><span class="operator">::</span>staticMetaObject<span class="operator">.</span>propertyOffset();

        <span class="comment">// ... and iterate over all its properties</span>
        <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> firstProperty; i <span class="operator">&lt;</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>propertyCount(); <span class="operator">+</span><span class="operator">+</span>i) {
            <span class="keyword">const</span> <span class="type">int</span> position <span class="operator">=</span> i <span class="operator">-</span> firstProperty;

            <span class="comment">// Retrieve the type, name and value of the current property</span>
            <span class="keyword">const</span> <span class="type">QString</span> type <span class="operator">=</span> typeName(metaObject<span class="operator">,</span> i);
            <span class="keyword">const</span> <span class="type">QString</span> name <span class="operator">=</span> <span class="type">QString</span><span class="operator">::</span>fromLatin1(metaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i)<span class="operator">.</span>name());
            <span class="keyword">const</span> <span class="type">QVariant</span> value <span class="operator">=</span> metaObject<span class="operator">-</span><span class="operator">&gt;</span>property(i)<span class="operator">.</span>read(reading);

            <span class="comment">// Fill the values in a new entry for the model</span>
            <span class="type">QVariantMap</span> readingEntry;
            readingEntry<span class="operator">[</span><span class="string">&quot;position&quot;</span><span class="operator">]</span> <span class="operator">=</span> position;
            readingEntry<span class="operator">[</span><span class="string">&quot;type&quot;</span><span class="operator">]</span> <span class="operator">=</span> type;
            readingEntry<span class="operator">[</span><span class="string">&quot;name&quot;</span><span class="operator">]</span> <span class="operator">=</span> name;
            readingEntry<span class="operator">[</span><span class="string">&quot;value&quot;</span><span class="operator">]</span> <span class="operator">=</span> convertValue(type<span class="operator">,</span> value);

            <span class="comment">// Find the entry in the model that represents the current property (based on the position) ...</span>
            <span class="keyword">const</span> <span class="type">QVariantList</span> indexPath <span class="operator">=</span> m_readingPropertiesModel<span class="operator">-</span><span class="operator">&gt;</span>find(<span class="type">QVariantList</span>() <span class="operator">&lt;</span><span class="operator">&lt;</span> position);

            <span class="comment">// ... and update the entry with the new data</span>
            m_readingPropertiesModel<span class="operator">-</span><span class="operator">&gt;</span>updateItem(indexPath<span class="operator">,</span> readingEntry);
        }

        <span class="keyword">return</span> <span class="keyword">false</span>;
    }</pre>
</div>
<!-- @@@sensors/sensorexplorer -->
  <div class="ft">
    <span></span>
  </div>
</div> 
<div class="footer">
  <p>
     Copyright 2012 Research In Motion Limited.
  <br />
    This document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
    Free Documentation License version 1.3</a>
    as published by the Free Software Foundation.</p>
</div>
</body>
</html>
